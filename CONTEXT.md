# Context - bkl Project

## CRITICAL INSTRUCTIONS - MUST FOLLOW

1. **Remember Rule**: When the user says "remember", IMMEDIATELY update this file to move the rule that needs to be remembered to the top of this CRITICAL INSTRUCTIONS section.

2. **Simple commits**: One-line commit messages ONLY. NEVER add "Generated by Claude" footers, emojis, or any multi-line messages. Just describe what changed in one line.

3. **Commit**: When asked to "commit", do: 1) update CONTEXT.md if needed, 2) run all tests with `just`, 3) stage changes with `git add -A`, 4) commit with simple message, 5) push with `git push`

4. **Test management**: 
   - MUST run all tests before moving on to add any new tests
   - MUST check with the user before moving on to add any new tests
   - MUST check with the user before deleting any tests

5. **Error handling**: Always propagate errors with proper messages, never silently handle errors

6. **No one-off scripts**: Never create temporary test scripts, always use inline debugging

7. **Never run bkl manually**: Never run `bkl` manually for testing - always use `just` or test commands

8. **Never change directories**: Never change directories with `cd` - always use absolute paths instead

## Project Overview
bkl is a flexible configuration templating language that simplifies configuration management across environments. Key capabilities:
- **Multi-format support**: Handles YAML, JSON, TOML seamlessly
- **Automatic inheritance**: Uses filename patterns (e.g., `service.test.yaml` inherits from `service.yaml`)
- **Manual inheritance**: Via `$parent` directives and wildcard patterns
- **Intelligent merging**: Maps and lists merge by default, with override options
- **String interpolation**: `$"Hello {variable}"` syntax for dynamic values
- **Environment variables**: `$env:VAR` for runtime configuration
- **Transformations**: `$encode`, `$decode`, `$merge` for data manipulation
- **Stream processing**: Handle multiple documents with `$match` and `$output`
- **Utility features**: `$repeat`, `$delete`, `$replace`, required field validation

## Testing Framework
- **Dual test systems**: 
  - Integration tests in `tests/` directory (each test has its own subdirectory)
  - Language tests in `tests.toml` (centralized TOML file with all test cases)
- **Integration tests** (`tests/` directory):
  - Test structure: `a.yaml` (input), `cmd` (command to run), `expected` (expected output)
  - Use `./test` to run all tests or `./test <test-name>` for specific test
  - For expected failures: use `! bkl` in cmd file and empty expected output
- **Language tests** (`tests.toml` file):
  - Centralized test definitions in TOML format
  - Each test specifies: `description`, `eval` (file to evaluate), `format` (output format), `expected` (expected output), `files` (map of filename to content)
  - Run with `go test -run TestLanguage`
  - Run specific tests with `go test -run TestLanguage -test.filter=test1,test2,test3`
  - Tests run in parallel with in-memory filesystem (fstest.MapFS)
  - Migrated from individual golang test files for better maintainability
  - Test names use camelCase convention
  - Organized into sections: Map Operations, List Operations, Match Operations, Parent/Inheritance, Output Control, Special Characters, Format Support, Encode/Decode, Interpolation, Repeat Operations, Type Handling
- **Test naming**: Use descriptive names without "bug", "debug", or "tmp" (tests are kept permanently)
  - Patterns: `parent-*`, `interp-*`, `merge-*`, `encode-*`, `match-*`, etc.
  - Use "null" not "nil" in test names (language perspective vs implementation)
  - Use short values in tests: a/b/c, 1/2/3, x/y/z instead of full words

## Key Files and Architecture
- `file.go`: File loading and parent resolution
- `document.go`: Document structure and processing
- `parser.go`: Main parser logic and document merging
- `process1.go`/`process2.go`: Document processing phases
- `merge.go`: Merge logic for combining documents and handling type conflicts
- `yaml.go`: YAML parsing using standard library decoder instead of regex
- `error.go`: Centralized error definitions with base `Err`
- `fs.go`: Filesystem abstraction with working directory support
- `filepath.go`: File path utilities and extension handling
- `language_test.go`: Go test wrapper for tests.toml-based language tests

## Error Handling Patterns
- All errors inherit from base `Err` using `fmt.Errorf("message (%w)", Err)`
- Existing error types: `ErrCircularRef`, `ErrMissingFile`, `ErrVariableNotFound`, etc.
- Tests expecting failures use `! bkl` and empty expected output

## Code Style Observations
- Uses standard library `slices` package for modern Go idioms
- Error messages include context (file paths, variable names)
- Consistent naming: functions use camelCase, test directories use kebab-case
- Import organization: standard library first, then third-party

## Development Expectations
- **Minimal comments**: Only add comments when absolutely critical for disambiguation
- **Standard library preferred**: Use `slices.Contains()` instead of hand-rolled loops
- **Proper error handling**: Use `io.EOF` comparison, not string matching
- **Clean imports**: Remove unused imports, organize standard library first
- **Test-driven**: Write tests for new features before implementing them, and tests that demonstrate problems before fixing them
- **Standards compliance**: Prefer standard library implementations over custom parsing
- **Code quality**: The linter (`gofumpt`, `go vet`) will automatically format code
- **Comprehensive testing**: Use `just` to run the full test pipeline before committing
- **Configuration errors should fail with proper error messages, not silent success**
- **File maintenance**: Clean up and reorganize CONTEXT.md sections as needed during updates
- **No line numbers**: Don't cite specific line numbers in documentation as they become stale
- **No implementation details**: Don't describe specific implementation details that change with code

## Commands for Development
- `just` - Run complete build and test pipeline (preferred)
  - Includes Go unit tests with race detection and coverage reporting
  - Runs integration tests via `./test`
  - Performs linting with `go vet` and formatting with `gofumpt`
  - Generates coverage report at `cover.html`
- `./test` - Run integration tests only
- `./test <test-name>` - Run specific integration test
- `COVERAGE=1 ./test` - Run integration tests with coverage profiling
  - Generates `integration-coverage.html` and `integration-coverage.out`
- `just test-coverage` - Run all integration tests with coverage
- `go build ./cmd/bkl` - Build main binary
- Tests are comprehensive with many integration tests plus Go unit tests

## Merge Behavior
- Maps merge recursively by default, with special `$replace` directive to override
- Lists append by default, with `$match`, `$delete`, and `$replace` directives for control
- **Type conflicts**: When merging different types, the source value replaces the destination
  - This includes maps, lists, strings, numbers, and null values
  - Merging any non-map value (including null) into a map replaces the entire map
- Empty maps can be overridden by any value without error
- Cross-document merging follows filename inheritance patterns
- **Match behavior**: `$match` uses partial matching (`x: {}` matches any map with an `x` key)
- **Null handling**: `null` values are preserved and can override existing values
  - Empty YAML documents (which parse as null) are now preserved in output
  - Null values in lists are preserved (not filtered out)
  - Consistent behavior: null is treated like any other value, not as a special "delete" marker

## Output Directives
- `$output: true` marks content for inclusion in final output
- `$output: false` excludes content from final output
  - Uses a boolean return value to properly distinguish between "value is null" and "exclude from output"
- **Ambiguity resolution**: In maps within lists, presence of other keys determines scope
  - Map with only `$output: true` → applies to list
  - Map with `$output: true` + other keys → applies to map

## Interpolation Syntax
- String interpolation: `$"Hello {variable} world"`
- Environment variables: `$env:VARNAME` 
- Cross-document references and path navigation supported
- Missing variables properly return errors

## Repeat Functionality
- `$repeat` supports four modes: integer count, list of values, key-value map, and range parameters
- **Integer mode**: `$repeat: 5` creates 5 copies with `$repeat` variable as 0,1,2,3,4
- **List mode**: `$repeat: ["apple", "banana", "cherry"]` creates copies with `$repeat` variable as each list value
  - Works with any value type: strings, numbers, booleans, etc.
  - Example: `$repeat: [42, "hello", true]` iterates over mixed types
- **Key-value mode**: `$repeat: {x: 2, y: 3}` creates cross-product of iterations
- **Range parameters mode**: `$repeat: {$first: 5, $last: 10}` creates sequence with specific values
  - Supports `$first`, `$last`, `$count`, `$step` parameters
  - Must specify exactly 2 of `$first`, `$last`, `$count` (cannot specify all 3)
  - `$step` defaults to 1, cannot be 0
  - `$count` must be positive
  - For `$first`/`$last` combinations, validates that `(last-first) % step == 0`
- **Nested range parameters**: Key-value maps can contain range parameter objects
  - Example: `$repeat: {a: 2, b: {$first: 10, $step: 2, $count: 3}}` creates cross-product
  - Mixed integer and range parameter values are supported
- All repeat modes (integer, list, key-value map, range parameters) work in both document-level and object-level contexts
- When using `$repeat` in map keys, use string interpolation: `$"item-{$repeat}"`
- Variables created by key-value repeat can be accessed as `$repeat:keyname` in strings and interpolations
# Context - bkl Project

## Project Overview
bkl is a flexible configuration templating language that simplifies configuration management across environments. Key capabilities:
- **Multi-format support**: Handles YAML, JSON, TOML seamlessly
- **Automatic inheritance**: Uses filename patterns (e.g., `service.test.yaml` inherits from `service.yaml`)
- **Manual inheritance**: Via `$parent` directives and wildcard patterns
- **Intelligent merging**: Maps and lists merge by default, with override options
- **String interpolation**: `$"Hello {variable}"` syntax for dynamic values
- **Environment variables**: `$env:VAR` for runtime configuration
- **Transformations**: `$encode`, `$decode`, `$merge` for data manipulation
- **Stream processing**: Handle multiple documents with `$match` and `$output`
- **Utility features**: `$repeat`, `$delete`, `$replace`, required field validation

## Testing Framework
- Tests are in `tests/` directory, each test has its own subdirectory
- Test structure: `a.yaml` (input), `cmd` (command to run), `expected` (expected output)
- Use `./test` to run all tests or `./test <test-name>` for specific test
- For expected failures: use `! bkl` in cmd file and empty expected output
- **Test naming**: Use descriptive names without "bug", "debug", or "tmp" (tests are kept permanently)
  - Patterns: `parent-*`, `interp-*`, `merge-*`, `encode-*`, `match-*`, `map-delete-*`, etc.
- **Expected output files**: Always include trailing newline to avoid test failures
- **Debugging test failures**: Command line arguments in `cmd` files must include file extensions (e.g., `bkl a.yaml` not `bkl a`)
- **Fixing missing newlines**: Use `echo "" >> tests/test-name/expected` to add trailing newline when tests fail due to newline mismatches

## Key Files and Architecture
- `file.go`: File loading and parent resolution
- `document.go`: Document structure and processing
- `parser.go`: Main parser logic and document merging
- `process1.go`/`process2.go`: Document processing phases
- `merge.go`: Merge logic for combining documents and handling type conflicts
- `yaml.go`: YAML parsing using standard library decoder instead of regex
- `error.go`: Centralized error definitions with base `Err`

## Error Handling Patterns
- All errors inherit from base `Err` using `fmt.Errorf("message (%w)", Err)`
- Existing error types: `ErrCircularRef`, `ErrMissingFile`, `ErrVariableNotFound`, etc.
- Tests expecting failures use `! bkl` and empty expected output

## Code Style Observations
- Uses standard library `slices` package for modern Go idioms
- Error messages include context (file paths, variable names)
- Consistent naming: functions use camelCase, test directories use kebab-case
- Import organization: standard library first, then third-party

## Development Expectations
- **Minimal comments**: Only add comments when absolutely critical for disambiguation
- **Standard library preferred**: Use `slices.Contains()` instead of hand-rolled loops
- **Proper error handling**: Use `io.EOF` comparison, not string matching
- **Clean imports**: Remove unused imports, organize standard library first
- **CRITICAL - Simple commits**: One-line commit messages ONLY. NEVER add "Generated by Claude" footers, emojis, or any multi-line messages. Just describe what changed in one line.
- **Test-driven**: Write tests for new features before implementing them, and tests that demonstrate problems before fixing them
- **Standards compliance**: Prefer standard library implementations over custom parsing
- **Code quality**: The linter (`gofumpt`, `go vet`) will automatically format code
- **Comprehensive testing**: Use `just` to run the full test pipeline before committing
- **Configuration errors should fail with proper error messages, not silent success**
- **Always update CONTEXT.md**: After completing any task, update this file with new learnings
- **File maintenance**: Clean up and reorganize CONTEXT.md sections as needed during updates
- **No line numbers**: Don't cite specific line numbers in documentation as they become stale
- **No implementation details**: Don't describe specific implementation details that change with code
- **CRITICAL - Test file format**: ALL test expected files MUST end with a newline character. Use `echo "" >> expected` to add trailing newlines when tests fail due to newline mismatches. This is NOT optional.

## Commands for Development
- `just` - Run complete build and test pipeline (preferred)
  - Includes Go unit tests with race detection and coverage reporting
  - Runs integration tests via `./test`
  - Performs linting with `go vet` and formatting with `gofumpt`
  - Generates coverage report at `cover.html`
- `./test` - Run integration tests only
- `./test <test-name>` - Run specific integration test
- `go build ./cmd/bkl` - Build main binary
- Tests are comprehensive with 160+ integration tests plus Go unit tests

## Merge Behavior
- Maps merge recursively by default, with special `$replace` directive to override
- Lists append by default, with `$match`, `$delete`, and `$replace` directives for control
- **Type conflicts**: Non-map values (strings, numbers, etc.) override maps completely
  - String-to-map override behavior: string overrides the entire map (implemented in `merge.go` `mergeMap` function)
- Empty maps can be overridden by any value without error
- Cross-document merging follows filename inheritance patterns
- **Match behavior**: `$match` uses partial matching (`x: {}` matches any map with an `x` key)
- **Delete after merge**: `$delete` directives work with `$merge` operations in the same map

## Output Directives
- `$output: true` marks content for inclusion in final output
- **Ambiguity resolution**: In maps within lists, presence of other keys determines scope
  - Map with only `$output: true` → applies to list
  - Map with `$output: true` + other keys → applies to map

## Interpolation Syntax
- String interpolation: `$"Hello {variable} world"`
- Environment variables: `$env:VARNAME` 
- Cross-document references and path navigation supported
- Missing variables properly return errors

## Repeat Functionality
- `$repeat` supports four modes: integer count, list of values, key-value map, and range parameters
- **Integer mode**: `$repeat: 5` creates 5 copies with `$repeat` variable as 0,1,2,3,4
- **List mode**: `$repeat: ["apple", "banana", "cherry"]` creates copies with `$repeat` variable as each list value
  - Works with any value type: strings, numbers, booleans, etc.
  - Example: `$repeat: [42, "hello", true]` iterates over mixed types
- **Key-value mode**: `$repeat: {x: 2, y: 3}` creates cross-product of iterations
- **Range parameters mode**: `$repeat: {$first: 5, $last: 10}` creates sequence with specific values
  - Supports `$first`, `$last`, `$count`, `$step` parameters
  - Must specify exactly 2 of `$first`, `$last`, `$count` (cannot specify all 3)
  - `$step` defaults to 1, cannot be 0
  - `$count` must be positive
  - For `$first`/`$last` combinations, validates that `(last-first) % step == 0`
- **Nested range parameters**: Key-value maps can contain range parameter objects
  - Example: `$repeat: {a: 2, b: {$first: 10, $step: 2, $count: 3}}` creates cross-product
  - Mixed integer and range parameter values are supported
- All repeat modes (integer, list, key-value map, range parameters) work in both document-level and object-level contexts
- When using `$repeat` in map keys, use string interpolation: `$"item-{$repeat}"`
- Variables created by key-value repeat can be accessed as `$repeat:keyname` in strings and interpolations
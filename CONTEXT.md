# Context - bkl Project

## Project Overview
bkl is a flexible configuration templating language that simplifies configuration management across environments. Key capabilities:
- **Multi-format support**: Handles YAML, JSON, TOML seamlessly
- **Automatic inheritance**: Uses filename patterns (e.g., `service.test.yaml` inherits from `service.yaml`)
- **Manual inheritance**: Via `$parent` directives and wildcard patterns
- **Intelligent merging**: Maps and lists merge by default, with override options
- **String interpolation**: `$"Hello {variable}"` syntax for dynamic values
- **Environment variables**: `$env:VAR` for runtime configuration
- **Transformations**: `$encode`, `$decode`, `$merge` for data manipulation
- **Stream processing**: Handle multiple documents with `$match` and `$output`
- **Utility features**: `$repeat`, `$delete`, `$replace`, required field validation

## Testing Framework
- **Dual test systems**: 
  - Integration tests in `tests/` directory (each test has its own subdirectory)
  - Language tests in `tests.toml` (centralized TOML file with all test cases)
- **Integration tests** (`tests/` directory):
  - Test structure: `a.yaml` (input), `cmd` (command to run), `expected` (expected output)
  - Use `./test` to run all tests or `./test <test-name>` for specific test
  - For expected failures: use `! bkl` in cmd file and empty expected output
- **Language tests** (`tests.toml` file):
  - Centralized test definitions in TOML format
  - Each test specifies: `eval` (file to evaluate), `format` (output format), `expected` (expected output), `files` (map of filename to content)
  - Run with `go test -run TestLanguage`
  - Run single test with `go test -run TestLanguage -test.single="test-name"`
  - Tests run in parallel with in-memory filesystem (fstest.MapFS)
- **Test naming**: Use descriptive names without "bug", "debug", or "tmp" (tests are kept permanently)
  - Patterns: `parent-*`, `interp-*`, `merge-*`, `encode-*`, `match-*`, etc.
  - Use "null" not "nil" in test names (language perspective vs implementation)
  - Use short values in tests: a/b/c, 1/2/3, x/y/z instead of full words
- **Expected output files**: Always include trailing newline to avoid test failures
- **Debugging test failures**: Command line arguments in `cmd` files must include file extensions (e.g., `bkl a.yaml` not `bkl a`)
- **Fixing missing newlines**: Use `echo "" >> tests/test-name/expected` to add trailing newline when tests fail due to newline mismatches

## Key Files and Architecture
- `file.go`: File loading and parent resolution
- `document.go`: Document structure and processing
- `parser.go`: Main parser logic and document merging
- `process1.go`/`process2.go`: Document processing phases
- `merge.go`: Merge logic for combining documents and handling type conflicts
- `yaml.go`: YAML parsing using standard library decoder instead of regex
- `error.go`: Centralized error definitions with base `Err`
- `fs.go`: Filesystem abstraction with working directory support
- `filepath.go`: File path utilities and extension handling
- `language_test.go`: Go test wrapper for tests.toml-based language tests

## Error Handling Patterns
- All errors inherit from base `Err` using `fmt.Errorf("message (%w)", Err)`
- Existing error types: `ErrCircularRef`, `ErrMissingFile`, `ErrVariableNotFound`, etc.
- Tests expecting failures use `! bkl` and empty expected output

## Code Style Observations
- Uses standard library `slices` package for modern Go idioms
- Error messages include context (file paths, variable names)
- Consistent naming: functions use camelCase, test directories use kebab-case
- Import organization: standard library first, then third-party

## Development Expectations
- **Minimal comments**: Only add comments when absolutely critical for disambiguation
- **Standard library preferred**: Use `slices.Contains()` instead of hand-rolled loops
- **Proper error handling**: Use `io.EOF` comparison, not string matching
- **Clean imports**: Remove unused imports, organize standard library first
- **CRITICAL - Simple commits**: One-line commit messages ONLY. NEVER add "Generated by Claude" footers, emojis, or any multi-line messages. Just describe what changed in one line.
- **Test-driven**: Write tests for new features before implementing them, and tests that demonstrate problems before fixing them
- **Standards compliance**: Prefer standard library implementations over custom parsing
- **Code quality**: The linter (`gofumpt`, `go vet`) will automatically format code
- **Comprehensive testing**: Use `just` to run the full test pipeline before committing
- **Configuration errors should fail with proper error messages, not silent success**
- **Always update CONTEXT.md**: After completing any task, update this file with new learnings
- **File maintenance**: Clean up and reorganize CONTEXT.md sections as needed during updates
- **No line numbers**: Don't cite specific line numbers in documentation as they become stale
- **No implementation details**: Don't describe specific implementation details that change with code
- **CRITICAL - Test file format**: ALL test expected files MUST end with a newline character. Use `echo "" >> expected` to add trailing newlines when tests fail due to newline mismatches. This is NOT optional.
- **CRITICAL - Commit steps**: When asked to "commit steps" or "commit", do: 1) stage changes with `git add -A`, 2) commit with simple message, 3) push with `git push`, 4) update CONTEXT.md if needed
- **CRITICAL - Test management**: 
  1) MUST run all tests before moving on to add any new tests
  2) MUST check with the user before moving on to add any new tests
  3) MUST check with the user before deleting any tests
- **CRITICAL - Error handling**: Always propagate errors with proper messages, never silently handle errors
- **CRITICAL - No one-off scripts**: Never create temporary test scripts, always use inline debugging
- **CRITICAL - Debug output**: When debugging, always output to stderr not stdout to avoid interfering with test output

## Commands for Development
- `just` - Run complete build and test pipeline (preferred)
  - Includes Go unit tests with race detection and coverage reporting
  - Runs integration tests via `./test`
  - Performs linting with `go vet` and formatting with `gofumpt`
  - Generates coverage report at `cover.html`
- `./test` - Run integration tests only
- `./test <test-name>` - Run specific integration test
- `COVERAGE=1 ./test` - Run integration tests with coverage profiling
  - Generates `integration-coverage.html` and `integration-coverage.out`
- `just test-coverage` - Run all integration tests with coverage
- `go build ./cmd/bkl` - Build main binary
- Tests are comprehensive with many integration tests plus Go unit tests
- **IMPORTANT**: Never run `bkl` manually for testing - always use `just` or `./test` commands
- **IMPORTANT**: Never create one-off test scripts - use inline debugging instead
- **IMPORTANT**: When debugging, output to stderr not stdout to avoid interfering with test output

## Merge Behavior
- Maps merge recursively by default, with special `$replace` directive to override
- Lists append by default, with `$match`, `$delete`, and `$replace` directives for control
- **Type conflicts**: When merging different types, the source value replaces the destination
  - This includes maps, lists, strings, numbers, and null values
  - Merging any non-map value (including null) into a map replaces the entire map
- Empty maps can be overridden by any value without error
- Cross-document merging follows filename inheritance patterns
- **Match behavior**: `$match` uses partial matching (`x: {}` matches any map with an `x` key)
- **Null handling**: `null` values are preserved and can override existing values
  - Empty YAML documents (which parse as null) are now preserved in output
  - Null values in lists are preserved (not filtered out)
  - Consistent behavior: null is treated like any other value, not as a special "delete" marker

## Output Directives
- `$output: true` marks content for inclusion in final output
- `$output: false` excludes content from final output
  - Uses a boolean return value to properly distinguish between "value is null" and "exclude from output"
- **Ambiguity resolution**: In maps within lists, presence of other keys determines scope
  - Map with only `$output: true` → applies to list
  - Map with `$output: true` + other keys → applies to map

## Interpolation Syntax
- String interpolation: `$"Hello {variable} world"`
- Environment variables: `$env:VARNAME` 
- Cross-document references and path navigation supported
- Missing variables properly return errors

## Repeat Functionality
- `$repeat` supports four modes: integer count, list of values, key-value map, and range parameters
- **Integer mode**: `$repeat: 5` creates 5 copies with `$repeat` variable as 0,1,2,3,4
- **List mode**: `$repeat: ["apple", "banana", "cherry"]` creates copies with `$repeat` variable as each list value
  - Works with any value type: strings, numbers, booleans, etc.
  - Example: `$repeat: [42, "hello", true]` iterates over mixed types
- **Key-value mode**: `$repeat: {x: 2, y: 3}` creates cross-product of iterations
- **Range parameters mode**: `$repeat: {$first: 5, $last: 10}` creates sequence with specific values
  - Supports `$first`, `$last`, `$count`, `$step` parameters
  - Must specify exactly 2 of `$first`, `$last`, `$count` (cannot specify all 3)
  - `$step` defaults to 1, cannot be 0
  - `$count` must be positive
  - For `$first`/`$last` combinations, validates that `(last-first) % step == 0`
- **Nested range parameters**: Key-value maps can contain range parameter objects
  - Example: `$repeat: {a: 2, b: {$first: 10, $step: 2, $count: 3}}` creates cross-product
  - Mixed integer and range parameter values are supported
- All repeat modes (integer, list, key-value map, range parameters) work in both document-level and object-level contexts
- When using `$repeat` in map keys, use string interpolation: `$"item-{$repeat}"`
- Variables created by key-value repeat can be accessed as `$repeat:keyname` in strings and interpolations
# bkl Documentation Sections
# Ordered list of documentation sections

- id: example
  title: Example
  items:
    - side_by_side:
        left:
          label: service.yaml
          code: |
            addr: 127.0.0.1
            name: myService
            port: 8080
        right:
          label: service.test.toml
          code: |
            port = 8081
          highlights: ["8081"]
    - code:
        label: "Run it!"
        code: |
          $ bkl service.test.toml
          addr = '127.0.0.1'
          name = 'myService'
          port = 8081
        highlights: ["8081"]
    - content: |
        bkl knows that <highlight>service.test.toml</highlight> inherits from <highlight>service.yaml</highlight> by the filename pattern (<a href="#inheritance">override with <highlight>$parent</highlight></a>) and uses filename extensions to determine formats.

- id: install
  title: Install
  items:
    - code:
        label: Using go
        code: |
          # Install go from <a href="https://go.dev/dl/">go.dev</a>
          $ go install github.com/gopatchy/bkl/...@latest
          # Verify that ~/go/bin is in your $PATH
    - code:
        label: macOS using brew
        code: |
          # Install brew from <a href="https://brew.sh/">brew.sh</a>
          $ brew install gopatchy/bkl/bkl
    - content: |
        You can also download binaries directly <a href="https://github.com/gopatchy/bkl/releases">here</a>.

- id: formats
  title: Formats
  items:
    - content: |
        Output defaults to the same format as the specified input file. Use <highlight>-f</highlight> (or <highlight>--format</highlight>) to override.
    - code:
        label: YAML
        code: |
          $ bkl -f yaml service.test.toml
          addr: 127.0.0.1
          name: myService
          port: 8081
        highlights: ["-f yaml"]
    - code:
        label: TOML
        code: |
          $ bkl -f toml service.test.toml
          addr = '127.0.0.1'
          name = 'myService'
          port = 8081
        highlights: ["-f toml"]
    - code:
        label: JSON
        code: |
          $ bkl -f json service.test.toml
          {"addr":"127.0.0.1","name":"myService","port":8081}
        highlights: ["-f json"]
    - code:
        label: JSON (pretty)
        code: |
          $ bkl -f json-pretty service.test.toml
          {
            "addr": "127.0.0.1",
            "name": "myService",
            "port": 8081
          }
        highlights: ["-f json-pretty"]
    - content: |
        <highlight>jsonl</highlight> is an alias for <highlight>json</highlight> to fully support <a href="https://jsonlines.org/">JSON Lines</a>.
    - content: |
        You can also set the output format implicitly by using a different file extension.
    - code:
        code: |
          $ bkl service.test.yaml   # real file is service.test.toml
          addr: 127.0.0.1
          name: myService
          port: 8081
        highlights: ["yaml", "toml"]

- id: write
  title: Output
  items:
    - content: |
        Output goes to stdout by default. Errors always go to stderr.
    - code:
        label: File Output
        code: |
          $ bkl -o out.yaml service.test.toml
        highlights: ["-o out.yaml"]
    - content: |
        Output format is autodetected from output filename (unless specified with <highlight>-f</highlight>).

- id: inputs
  title: Inputs
  items:
    - code:
        label: Commandline Layering
        code: |
          $ bkl a.b.yaml c.d.yaml   # a.yaml + a.b.yaml + c.yaml + c.d.yaml
        highlights: ["a.b.yaml c.d.yaml"]
    - content: |
        Specifying multiple input files merges all layers in order.
    - code:
        label: stdin
        code: |
          $ bkl -- -.yaml <<'EOF'
          a: 1
          EOF
        highlights: ["-- -.yaml"]
    - content: |
        Specifying an input file with the base name <highlight>-</highlight> and a valid format extension causes bkl to read that format from standard input. Use <highlight>--</highlight> before the filename to avoid it being treated as a flag.

- id: inheritance
  title: Inheritance
  items:
    - content: |
        Inheritance is determined using filenames by default. After stripping the extension, the remaining filename is split on <highlight>.</highlight> and treated as an inheritance hierarchy (e.g. <highlight>a.b.c.yaml</highlight> inherits from <highlight>a.b.&lt;ext&gt;</highlight> inherits from <highlight>a.&lt;ext&gt;</highlight>). Parent layers may have any supported file extension.
    - code:
        label: Set Parent In File
        code: |
          $parent: a.b   # inherits from a.b.<ext>, from a.<ext>
        highlights: ["$parent: a.b"]
    - content: |
        bkl will check for all supported endings of a manually-specified parent file and will still evaluate layers under the parent in the normal order.
    - side_by_side:
        left:
          label: Parent List
          code: |
            $parent:
            - a
            - b
          highlights: ["$parent:", "- a", "- b"]
        right:
          label: Parent Wildcard
          code: |
            $parent: a.*
          highlights: ["$parent: a.*"]
    - content: |
        Setting <highlight>$parent</highlight> to a list or wildcard allows inheriting from multiple files. All parent files are loaded before the child.
    - content: |
        <highlight>*</highlight> does not match <highlight>.</highlight>. <highlight>a.*</highlight> matches <highlight>a.b.yaml</highlight> but not <highlight>a.b.c.yaml</highlight>.
    - code:
        label: Set Parent In CLI
        code: |
          $ bkl a.b.yaml c.d.yaml      # a.yaml + a.b.yaml + c.yaml + c.d.yaml
        highlights: ["a.b.yaml c.d.yaml"]
    - content: |
        Layer order can be specified with commandline argument order.
    - code:
        label: No Parent
        code: |
          $parent: false   # no further inheritance
        highlights: ["$parent: false"]
    - content: |
        Setting <highlight>$parent</highlight> to <highlight>false</highlight> or <highlight>null</highlight> stops any further inheritance regardless of filename structure.

- id: streams
  title: Streams
  items:
    - content: |
        Streams package multiple documents into a single file. YAML/TOML streams are delimited with <highlight>---</highlight> or sometimes <highlight>+++</highlight>. JSON streams are concatenated or delimited with newlines (see <a href="https://jsonlines.org/">JSON Lines</a> and <a href="http://ndjson.org/">ndjson</a>).
    - content: |
        To layer streams, bkl has to match documents between layers. By default, child documents are applied to all parent documents. <highlight>$match</highlight> allows applying to specific parent documents.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
          - code: |
              c: 3
        result:
          code: |
            a: 1
            c: 3
            ---
            b: 2
            c: 3
          highlights: ["c: 3", "c: 3"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
          - code: |
              $match:
                b: 2
              c: 3
            highlights: ["$match:", "b: 2"]
        result:
          code: |
            a: 1
            ---
            b: 2
            c: 3
          highlights: ["c: 3"]
    - content: |
        The supplied pattern can match multiple documents and the updates will be applied to all of them. <highlight>$match: {}</highlight> matches any documents with a map as their root element, regardless of parent.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
              ---
              a: 1
          - code: |
              $match:
                a: 1
              c: 3
            highlights: ["$match:", "a: 1"]
        result:
          code: |
            a: 1
            c: 3
            ---
            b: 2
            ---
            a: 1
            c: 3
          highlights: ["c: 3", "c: 3"]
    - content: |
        <highlight>$invert: true</highlight> inside a <highlight>$match</highlight> block inverts the match, causing it to apply to any documents that do not contain the match criteria.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
          - code: |
              $match:
                a: 1
                $invert: true
              c: 3
            highlights: ["$invert: true"]
        result:
          code: |
            a: 1
            ---
            b: 2
            c: 3
          highlights: ["c: 3"]
    - content: |
        <highlight>$match: null</highlight> forces the updates to apply to a new document.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
          - code: |
              $match: null
              b: 2
            highlights: ["$match: null"]
        result:
          code: |
            a: 1
            ---
            b: 2
          highlights: ["b: 2"]

- id: maps
  title: Maps
  items:
    - content: |
        Maps are merged by default. To change that, use <highlight>$replace: true</highlight> or remove individual entries with <highlight>$delete</highlight>.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
          - code: |
              b: 2
        result:
          code: |
            a: 1
            b: 2
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
          - code: |
              b: 2
              $replace: true
            highlights: ["$replace: true"]
        result:
          code: |
            b: 2
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
          - code: |
              c: 3
              b: $delete
            highlights: ["b: $delete"]
        result:
          code: |
            a: 1
            c: 3
    - content: |
        bkl returns an error if you use <highlight>$delete</highlight>, <highlight>$replace: true</highlight>, or a <highlight>key: value</highlight> pair when they don't override a value from a lower layer. This helps keep upper layers minimal.

- id: lists
  title: Lists
  items:
    - content: |
        Lists are merged by default. To change that, use <highlight>$replace: true</highlight> or remove individual entries with <highlight>$delete</highlight>.
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
          - code: |
              - 2
        result:
          code: |
            - 1
            - 2
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
          - code: |
              - 2
              - $replace: true
            highlights: ["$replace: true"]
        result:
          code: |
            - 2
    - example:
        operation: evaluate
        layers:
          - code: |
              - x: 1
              - x: 2
          - code: |
              - x: 3
              - $delete:
                  x: 2
            highlights: ["$delete:", "x: 2"]
        result:
          code: |
            - x: 1
            - x: 3
    - content: |
        bkl returns an error if you use <highlight>$replace: true</highlight> or <highlight>$delete</highlight> when they don't override a value from a lower layer. This helps keep upper layers minimal.
    - content: |
        To update a specific list item from a parent layer, use <highlight>$match</highlight>. Combine it with <highlight>$value</highlight> for scalars.
    - example:
        operation: evaluate
        layers:
          - code: |
              - a: 1
              - b: 2
          - code: |
              - $match:
                  b: 2
                b: 10
            highlights: ["$match:", "b: 2"]
        result:
          code: |
            - a: 1
            - b: 10
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
              - 2
          - code: |
              - $match: 2
                $value: 10
            highlights: ["$match: 2", "$value: 10"]
        result:
          code: |
            - 1
            - 10

- id: interp
  title: $""
  items:
    - content: |
        Use <highlight>$""</highlight> to interpolate format strings with <a href="#merge"><highlight>$merge</highlight></a>-style references.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: foo
              d: $"{b.c} bar {a} 2"
            highlights: ["$\"{b.c} bar {a} 2\""]
        result:
          code: |
            a: 1
            b:
              c: foo
            d: foo bar 1 2
          highlights: ["foo bar 1 2"]

- id: decode
  title: $decode
  items:
    - content: |
        <highlight>$decode</highlight> transforms a string into a tree by parsing standard formats.
    - example:
        operation: evaluate
        layers:
          - code: |
              $value: |
                {"a":1}
              $decode: json
            highlights: ["{\"a\":1}", "$decode: json"]
        result:
          code: |
            a: 1
          highlights: ["a: 1"]

- id: env
  title: $env
  items:
    - content: |
        Use <highlight>$env:</highlight> to substitute environment variables. This is supported in keys and values.
    - example:
        operation: evaluate
        layers:
          - code: |
              # export FOO=test
              "$env:FOO": 1
            highlights: ["\"$env:FOO\""]
        result:
          code: |
            test: 1
          highlights: ["test"]
    - example:
        operation: evaluate
        layers:
          - code: |
              # export FOO=test
              a: $env:FOO
            highlights: ["$env:FOO"]
        result:
          code: |
            a: test
          highlights: ["test"]
    - content: |
        Note that all <highlight>$env:</highlight> substitutions result in string values even if the substituted value is <highlight>true</highlight>, <highlight>false</highlight>, <highlight>null</highlight>, or all digits.

- id: encode
  title: $encode
  items:
    - content: |
        <highlight>$encode</highlight> transforms the subtree into the specified format.
    - example:
        operation: evaluate
        layers:
          - label: base64
            code: |
              $value: a
              $encode: base64
            highlights: ["$encode: base64"]
        result:
          code: |
            YQ==
    - example:
        operation: evaluate
        layers:
          - label: flags
            code: |
              a: 1
              b: 2
              $encode: flags
              # [tolist:=, prefix:--]
            highlights: ["$encode: flags"]
        result:
          code: |
            - --a=1
            - --b=2
    - example:
        operation: evaluate
        layers:
          - label: flatten
            code: |
              - - a
                - b
              - - c
                - 4
              - e
              - $encode: flatten
            highlights: ["$encode: flatten"]
        result:
          code: |
            - a
            - b
            - c
            - 4
            - e
    - example:
        operation: evaluate
        layers:
          - label: join
            code: |
              $value: [a, b]
              $encode: join:/
            highlights: ["$encode: join:/"]
        result:
          code: |
            a/b
    - example:
        operation: evaluate
        layers:
          - label: json
            code: |
              a: 1
              b: 2
              $encode: json
            highlights: ["$encode: json"]
        result:
          code: |
            |
              {"a":1,"b":2}
    - example:
        operation: evaluate
        layers:
          - label: json (list)
            code: |
              - a: 1
              - b: 2
              - $encode: json
            highlights: ["$encode: json"]
        result:
          code: |
            |
              [{"a":1},{"b":2}]
    - example:
        operation: evaluate
        layers:
          - label: prefix
            code: |
              - a
              - 2
              - $encode: prefix:X
            highlights: ["$encode: prefix:X"]
        result:
          code: |
            - Xa
            - X2
    - example:
        operation: evaluate
        layers:
          - label: tolist
            code: |
              a: 1
              b: 2
              $encode: tolist:=
            highlights: ["$encode: tolist:="]
        result:
          code: |
            - a=1
            - b=2
    - example:
        operation: evaluate
        layers:
          - label: Stacking
            code: |
              a: 1
              b: 2
              $encode: [tolist:=, "join:,"]
            highlights: ["$encode: [tolist:=, \"join:,\"]"]
        result:
          code: |
            a=1,b=2

- id: required
  title: $required
  items:
    - content: |
        Use <highlight>$required</highlight> in lower layers to force upper layers to replace the value.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: $required
            highlights: ["b: $required"]
          - code: |
              c: 3
        result:
          code: |
            Error
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: $required
            highlights: ["b: $required"]
          - code: |
              b: 2
              c: 3
            highlights: ["b: 2"]
        result:
          code: |
            a: 1
            b: 2
            c: 3
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                - $required
            highlights: ["b:", "- $required"]
          - code: |
              c: 3
        result:
          code: |
            Error
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                - $required
            highlights: ["b:", "- $required"]
          - code: |
              b:
                - 2
              c: 3
            highlights: ["b:", "- 2"]
        result:
          code: |
            a: 1
            b:
              - 2
            c: 3

- id: merge
  title: $merge
  items:
    - content: |
        Use <highlight>$merge</highlight> to merge the contents one subtree or scalar value into another.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                $merge: foo.bar
            highlights: ["$merge: foo.bar"]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              a: 1
              b: 2
          highlights: ["a: 1"]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - a: 1
              zig:
                - b: 2
                - $merge: foo.bar
            highlights: ["$merge: foo.bar"]
        result:
          code: |
            foo:
              bar:
                - a: 1
            zig:
              - b: 2
              - a: 1
          highlights: ["a: 1"]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                c: $merge:foo.bar.a
            highlights: ["$merge:foo.bar.a"]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              b: 2
              c: 1
          highlights: ["1"]
    - content: |
        You can also merge across documents using <highlight>$match</highlight> and optionally <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $merge:
                $match:
                  a: 1
            highlights: ["$merge:", "$match:", "a: 1"]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
            c: 3
          highlights: ["a: 1", "b: 2"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $merge:
                $match:
                  a: 1
                $path: b
            highlights: ["$merge:", "$match:", "a: 1", "$path: b"]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
            d: 4
          highlights: ["c: 3"]
    - content: |
        <highlight>$merge</highlight> also supports a shorthand syntax equivalent to <highlight>$match</highlight> and <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $merge: <value>[{a: 1}]</value>
            highlights: ["$merge: <value>[{a: 1}]</value>"]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
            c: 3
          highlights: ["a: 1", "b: 2"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $merge: <value>[{a: 1}, b]</value>
            highlights: ["$merge: <value>[{a: 1}, b]</value>"]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
            d: 4
          highlights: ["c: 3"]

- id: replace
  title: $replace
  items:
    - content: |
        Use <highlight>$replace</highlight> to merge the contents of one subtree or scalar value with another.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                $replace: foo.bar
            highlights: ["$replace: foo.bar"]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              a: 1
          highlights: ["a: 1"]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - a: 1
              zig:
                - b: 2
                - $replace: foo.bar
            highlights: ["$replace: foo.bar"]
        result:
          code: |
            foo:
              bar:
                - a: 1
            zig:
              - a: 1
          highlights: ["a: 1"]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                c: $replace:foo.bar.a
            highlights: ["$replace:foo.bar.a"]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              b: 2
              c: 1
          highlights: ["1"]
    - content: |
        Note that <highlight>$merge</highlight> and <highlight>$replace</highlight> are equivalent for scalar values.
    - content: |
        You can also replace across documents using <highlight>$match</highlight> and optionally <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $replace:
                $match:
                  a: 1
            highlights: ["$replace:", "$match:", "a: 1"]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
          highlights: ["a: 1", "b: 2"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $replace:
                $match:
                  a: 1
                $path: b
            highlights: ["$replace:", "$match:", "a: 1", "$path: b"]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
    - content: |
        <highlight>$replace</highlight> also supports a shorthand syntax equivalent to <highlight>$match</highlight> and <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $replace: <value>[{a: 1}]</value>
            highlights: ["$replace: <value>[{a: 1}]</value>"]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
          highlights: ["a: 1", "b: 2"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $replace: <value>[{a: 1}, b]</value>
            highlights: ["$replace: <value>[{a: 1}, b]</value>"]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
          highlights: ["c: 3"]

- id: output
  title: $output
  items:
    - content: |
        Use <highlight>$output: true</highlight> to select a subtree for output instead of the document root.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  $output: true
                  a: 1
                  b: 2
            highlights: ["$output: true"]
        result:
          code: |
            a: 1
            b: 2
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - $output: true
                  - a: 1
                  - b: 2
            highlights: ["$output: true"]
        result:
          code: |
            - a: 1
            - b: 2
    - content: |
        Multiple instances of <highlight>$output: true</highlight> in a document will generate multiple output documents (delimited with <highlight>---</highlight>).
    - content: |
        Use <highlight>$output: false</highlight> to omit a subtree or entire document from the output.
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                b: 1
                $output: false
              c:
                d: 2
            highlights: ["$output: false"]
        result:
          code: |
            c:
              d: 2
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - b: 1
                - $output: false
              c:
                - d: 2
            highlights: ["$output: false"]
        result:
          code: |
            c:
              - d: 2
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              $output: false
              ---
              b: 2
            highlights: ["$output: false"]
        result:
          code: |
            b: 2
    - content: |
        Combine <highlight>$output</highlight> with <highlight>$replace</highlight> or <highlight>$merge</highlight> to have hidden "template" subtrees that don't appear in the output but can be copied in as needed.

- id: repeat
  title: $repeat
  items:
    - content: |
        <highlight>$repeat:</highlight> at the top level of a document causes the document to be duplicated the given number of times. Within the document, <highlight>$repeat</highlight> can be used to reference the zero-based repeat index.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: foo
              b: $repeat
              $repeat: 2
            highlights: ["$repeat: 2", "b: $repeat"]
        result:
          code: |
            a: foo
            b: 0
            ---
            a: foo
            b: 1
    - content: |
        <highlight>$repeat:</highlight> can also contain a map of named repeat iterators to repeat count. The result is the cartesian product (all combinations) of repeat values.
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat:
                a: 2
                b: 3
              $value: $"{$repeat:a},{$repeat:b}"
            highlights: ["$repeat:", "a: 2", "b: 3", "$repeat:a", "$repeat:b"]
        result:
          code: |
            0,0
            ---
            0,1
            ---
            0,2
            ---
            1,0
            ---
            1,1
            ---
            1,2
    - content: |
        <highlight>$repeat:</highlight> can contain a list of values to iterate over:
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat: [x, y, z]
              a: $repeat
            highlights: ["$repeat: [x, y, z]", "a: $repeat"]
        result:
          code: |
            a: x
            ---
            a: y
            ---
            a: z
    - content: |
        <highlight>$repeat:</highlight> supports range parameters for numeric sequences:
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat:
                $first: 10
                $count: 3
              a: $repeat
            highlights: ["$repeat:", "$first: 10", "$count: 3", "a: $repeat"]
        result:
          code: |
            a: 10
            ---
            a: 11
            ---
            a: 12
    - content: |
        Range parameters require exactly 2 of <highlight>$first</highlight>, <highlight>$last</highlight>, and <highlight>$count</highlight>. Optional <highlight>$step</highlight> defaults to 1.
    - content: |
        <highlight>$repeat:</highlight> also works at the object level within maps and lists:
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                $"b{$repeat}":
                  c: $repeat
                  $repeat: 3
            highlights: ["$repeat: 3", "c: $repeat"]
        result:
          code: |
            a:
              b0:
                c: 0
              b1:
                c: 1
              b2:
                c: 2
    - content: |
        Object-level repeat in lists:
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - b: $repeat
                  $repeat: [x, y, z]
            highlights: ["$repeat: [x, y, z]", "b: $repeat"]
        result:
          code: |
            a:
              - b: x
              - b: y
              - b: z

- id: escape
  title: $$
  items:
    - content: |
        <highlight>$$</highlight> translates to a literal <highlight>$</highlight> in cases where it would otherwise trigger special handling.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: $$env:foo
            highlights: ["$$env:foo"]
        result:
          code: |
            a: $env:foo
          highlights: ["$env:foo"]

- id: toml
  title: TOML
  items:
    - content: |
        TOML doesn't allow unquoted <highlight>$</highlight> in keys, which impacts bkl directives. Work around this by quoting keys:
    - code:
        code: |
          "$parent" = false
        highlights: ["\"$parent\""]

- id: bklb
  title: bklb
  items:
    - content: |
        <highlight>bklb</highlight> is a wrapper for CLI programs that take configuration files as commandline arguments but do not support bkl format. It transparently merges layers, translates formats, writes to temporary files, alters the commandline arguments, then execs the wrapped program.
    - code:
        code: |
          $ ln -s ~/go/bin/bklb ~/go/bin/catb   # catb could be, e.g. kubectlb
          
          $ cat service.yaml
          addr: 127.0.0.1
          name: myService
          port: 8080
          
          $ cat service.test.toml
          port = 8081
          
          $ catb service.test.toml
          addr = "127.0.0.1"
          name = "myService"
          port = 8081
          
          $ cat service.test.yaml service.test.json
          cat: service.test.yaml: No such file or directory
          cat: service.test.json: No such file or directory
          
          $ catb service.test.yaml
          addr: 127.0.0.1
          name: myService
          port: 8081
          
          $ catb service.test.json
          {"addr":"127.0.0.1","name":"myService","port":8081}
        highlights: ["ln -s ~/go/bin/bklb ~/go/bin/catb", "catb service.test.toml", "catb service.test.yaml", "catb service.test.json"]
    - content: |
        Note that the files mentioned don't have to exist; <highlight>bklb</highlight> will search for files with the same root name but different extensions, then merge layers and translate into the specified format.
    - content: |
        <highlight>bklb</highlight> takes the name of the program it wraps from its own filename, hence the <highlight>ln -s</highlight> symlink creation in the example above. It trims at most one <highlight>b</highlight> from the end of its name before searching for the wrapped program so they can coexist in your PATH.

- id: bkld
  title: bkld
  items:
    - code:
        code: |
          $ bkld &lt;base_layer_path&gt; &lt;target_output_path&gt;
    - content: |
        <highlight>bkld</highlight> (d for "diff") generates the minimal intermediate layer needed to create the target output from the base layer. Along with <highlight><a href="#bkli">bkli</a></highlight>, it automates splitting existing configurations into layers.
    - example:
        operation: diff
        layers:
          - code: |
              a: 1
              b: $required
              c: 3
          - code: |
              a: 1
              b: 2
              d: 4
        result:
          code: |
            b: 2
            c: null
            d: 4
    - example:
        operation: diff
        layers:
          - code: |
              - a: 1
              - b: 2
          - code: |
              - a: 1
              - c: 3
        result:
          code: |
            - c: 3
            - $delete:
                b: 2
    - example:
        operation: diff
        layers:
          - code: |
              - 1
              - 2
          - code: |
              - 1
              - 3
        result:
          code: |
            - 1
            - 3
            - $replace: true

- id: bkli
  title: bkli
  items:
    - code:
        code: |
          $ bkli &lt;target_output_path&gt; &lt;target_output_path&gt; ...
    - content: |
        <highlight>bkli</highlight> (i for "intersect") generates the maximal base layer that the specified targets have in common. Along with <highlight><a href="#bkld">bkld</a></highlight>, it automates splitting existing configurations into layers.
    - content: |
        Any fields that exist in all upper layers but have different values will be marked <highlight>$required</highlight>.
    - example:
        operation: intersect
        layers:
          - code: |
              a: 1
              b: 2
              c: 3
          - code: |
              a: 1
              b: 10
              d: 4
        result:
          code: |
            a: 1
            b: $required
    - example:
        operation: intersect
        layers:
          - code: |
              - a: 1
              - b: 2
              - c: 3
          - code: |
              - a: 1
              - b: 10
              - d: 4
        result:
          code: |
            - a: 1

- id: bklr
  title: bklr
  items:
    - code:
        code: |
          $ bklr &lt;lower_layer_path&gt;
    - content: |
        <highlight>bklr</highlight> (r for "required") generates a document containing just the required fields and their ancestors from the lower layer. The output can be edited into a minimal upper layer.
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                b: $required
                c: 3
        result:
          code: |
            a:
              b: $required
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - $required
              b:
                - 2
        result:
          code: |
            a:
              - $required

- id: kubectl-bkl
  title: kubectl bkl
  items:
    - code:
        code: |
          $ kubectl bkl &lt;kubectl_commands&gt;
        highlights: ["bkl"]
    - content: |
        <highlight>kubectl bkl</highlight> is a kubectl plugin that wraps all the normal kubectl commands by evaluating any input files as bkl layers and passing the output to kubectl.
    - code:
        code: |
          # deploy.dev.yaml and deploy.yaml are bkl layer files
          $ kubectl bkl apply -f deploy.dev.yaml
          deployment.apps/deploy-dev unchanged

- id: docker
  title: Docker
  items:
    - content: |
        bkl docker images are available at <highlight>ghcr.io/gopatchy/bkl:latest</highlight> for amd64 and arm64. Compose these images for your development and CI/CD workflows.
    - code:
        label: Dockerfile
        code: |
          FROM ghcr.io/gopatchy/bkl:latest AS bkl
          
          FROM debian:latest AS build
          COPY --from=bkl /bin /bin

- id: diff
  title: diff
  items:
    - content: |
        It's easy to see differences between processed bkl files using shell syntax.
    - code:
        code: |
          $ diff -ud --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)
          --- /dev/fd/63  2023-07-12 21:00:55.412475845 -0700
          +++ /dev/fd/62  2023-07-12 21:00:55.412475845 -0700
          @@ -1,3 +1,2 @@
           a: 1
          -b: 2
           c: 3
          
          $ diff -y --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)
          a: 1                              a: 1
          b: 2                            &lt;
          c: 3                              c: 3
        highlights: ["diff -ud --color", "(bkl a.yaml)", "(bkl b.yaml)", "-b: 2", "diff -y --color", "&lt;"]

- id: migrate
  title: Migrate
  items:
    - content: |
        Below is an example process for migrating an existing set of configurations to <highlight>bkl</highlight>. It contains some Kubernetes-specific items but the use of the <highlight>bkl*</highlight> tools applies to any configuration source.
    - content: |
        We assume you start with two K8s deployments called <highlight>deploy-dev</highlight> and <highlight>deploy-prod</highlight> which are similar but not identical.
    - content: |
        First, install tools:
        
        <ul>
        <li><a href="#install">bkl</a></li>
        <li><a href="https://kubernetes.io/docs/tasks/tools/#kubectl">kubectl</a></li>
        <li><a href="https://krew.sigs.k8s.io/docs/user-guide/setup/install/">krew</a></li>
        <li><a href="https://github.com/itaysk/kubectl-neat#installation">neat</a></li>
        </ul>
    - content: |
        It's possible to export configuration directly from existing templating systems (e.g. <highlight>kustomize build</highlight>, <highlight>helm install --dry-run --debug</highlight>). Instead, we do this in a generic way and make sure we get the latest configuration by fetching it directly from the K8s API server.
    - code:
        label: Export Existing Config
        code: |
          # "kubectl neat" removes status and default value fields
          $ kubectl neat get -- deploy deploy-dev > deploy-dev-orig.yaml
          $ kubectl neat get -- deploy deploy-prod > deploy-prod-orig.yaml
    - code:
        label: Generate Base Layer
        code: |
          # See bkli details <a href="#bkli">here</a>
          $ bkli -o deploy.yaml deploy-dev-orig.yaml deploy-prod-orig.yaml
    - code:
        label: Generate Service Layers
        code: |
          # See bkld details <a href="#bkld">here</a>
          $ bkld -o deploy.dev.yaml deploy.yaml deploy-dev-orig.yaml
          $ bkld -o deploy.prod.yaml deploy.yaml deploy-prod-orig.yaml
    - code:
        label: Check Results
        code: |
          # Should show no diff
          $ kubectl bkl diff -f deploy.dev.yaml
          $ kubectl bkl diff -f deploy.prod.yaml
    - code:
        label: Clean Up
        code: |
          $ rm deploy-dev-orig.yaml deploy-prod-orig.yaml
    - content: |
        You now have 3 bkl files:
        
        <ul>
        <li><highlight>deploy.yaml</highlight> is the base layer containing values common to both deployments</li>
        <li><highlight>deploy.dev.yaml</highlight> is the upper layer containing values specific to <highlight>deploy-dev</highlight></li>
        <li><highlight>deploy.prod.yaml</highlight> is the upper layer containing values specific to <highlight>deploy-prod</highlight></li>
        </ul>
    - content: |
        The migration process isn't deterministic; there are design and aesthetic considerations. Here are some general tips:
        
        <ul>
        <li>Start with the most similar examples to maximize base layer size</li>
        <li>Consider intermediate layers that make sense (e.g. <highlight>deploy.yaml</highlight> → <highlight>deploy.frontend.yaml</highlight> → <highlight>deploy.frontend.prod.yaml</highlight>)</li>
        <li>Split large configurations into logical subfiles; bkl can merge across file boundaries</li>
        <li>Iterate by diffing your evaluated layers against production (e.g. <highlight>kubectl bkl diff -f</highlight>), making small changes, then diffing again.</li>
        <li>Migrate as much as possible to the lowest layer to reduce duplication and complexity.</li>
        <li>Consider making your base layer match your production configuration then overriding values for dev/test configurations. This makes it very clear where you're drifting away from production.</li>
        <li>Remove duplication with <highlight>$merge:</highlight> but avoid chained merge paths.</li>
        <li>Avoid using hidden <highlight>$output: false</highlight> trees as template variables; prefer overriding values in-place.</li>
        <li><highlight>bkld</highlight> doesn't know how to match entries within lists, so it may remove and replace large entries (e.g. K8s <highlight>containers</highlight>) that could be trivially patched. Use <highlight>$match:</highlight> to select the container and override values within it.</li>
        </ul>

- id: comparison
  title: Comparison
  items:
    - content: |
        bkl has some overlap with other configuration templating tools (e.g. <a href="https://helm.sh/">Helm</a>, <a href="https://kustomize.io/">Kustomize</a>, <a href="https://www.puppet.com/docs/puppet/8/hiera_intro.html">Hiera</a>). We believe that bkl has a combination of project goals that aren't fully served by any of the alternatives:
        
        <ul>
        <li>Configuration and templating/layering should be generic, not service-specific.</li>
        <li>Configuration and templating/layering should be separate from deployment tooling.</li>
        <li>Configuration files should be written in standard formats (JSON, YAML, TOML) and parseable by their standard parsers.</li>
        <li>Basic functionality should be available without learning custom syntax.</li>
        <li>Non-templatized configuration (e.g. StackOverflow answers) should be usable without modification.</li>
        <li>File composition should be accomplished without meta configuration (e.g. manifest files).</li>
        <li>Templating/layering behavior should be intuitive and produce expected results.</li>
        <li>Documentation and examples should be excellent.</li>
        </ul>
# bkl Documentation Sections
# Ordered list of documentation sections

- id: example
  title: Example
  items:
    - side_by_side:
        left:
          label: service.yaml
          code: |
            addr: 127.0.0.1
            name: myService
            port: 8080
          languages: [[0, "yaml"]]
        right:
          label: service.test.toml
          code: |
            port = 8081
          highlights: ["8081"]
          languages: [[0, "toml"]]
    - code:
        label: "Run it!"
        code: |
          $ bkl service.test.toml
          addr = '127.0.0.1'
          name = 'myService'
          port = 8081
        highlights: ["8081"]
        languages: [[0, "shell"], [1, "toml"]]
    - content: |
        bkl automatically inherits <highlight>service.test.toml</highlight> from <highlight>service.yaml</highlight> by filename pattern and handles format conversion.

- id: install
  title: Install
  items:
    - code:
        label: Using go
        code: |
          # Install go from <a href="https://go.dev/dl/">go.dev</a>
          $ go install github.com/gopatchy/bkl/...@latest
        languages: [[0, "shell"]]
    - code:
        label: brew (macOS)
        code: |
          # Install brew from <a href="https://brew.sh/">brew.sh</a>
          $ brew install gopatchy/bkl/bkl
        languages: [[0, "shell"]]
    - content: |
        Download binaries from <a href="https://github.com/gopatchy/bkl/releases">releases</a>.

- id: formats
  title: Formats
  items:
    - content: |
        Output defaults to input format. Use <highlight>-f</highlight> to override.
    - code:
        label: YAML
        code: |
          $ bkl -f yaml service.test.toml
          addr: 127.0.0.1
          name: myService
          port: 8081
        highlights: ["-f yaml"]
        languages: [[0, "shell"], [1, "yaml"]]
    - code:
        label: TOML
        code: |
          $ bkl -f toml service.test.toml
          addr = '127.0.0.1'
          name = 'myService'
          port = 8081
        highlights: ["-f toml"]
        languages: [[0, "shell"], [1, "toml"]]
    - code:
        label: JSON
        code: |
          $ bkl -f json service.test.toml
          {"addr":"127.0.0.1","name":"myService","port":8081}
        highlights: ["-f json"]
        languages: [[0, "shell"], [1, "json"]]
    - code:
        label: JSON (pretty)
        code: |
          $ bkl -f json-pretty service.test.toml
          {
            "addr": "127.0.0.1",
            "name": "myService",
            "port": 8081
          }
        highlights: ["-f json-pretty"]
        languages: [[0, "shell"], [1, "json"]]
    - content: |
        <highlight>jsonl</highlight> is an alias for <highlight>json</highlight> (see <a href="https://jsonlines.org/">JSON Lines</a>). Format is auto-detected from file extensions.
    - code:
        code: |
          $ bkl service.test.yaml   # real file is service.test.toml
          addr: 127.0.0.1
          name: myService
          port: 8081
        highlights: ["yaml", "toml"]
        languages: [[0, "shell"], [1, "yaml"]]

- id: write
  title: Output
  items:
    - content: |
        Output goes to stdout by default. Use <highlight>-o</highlight> to write to a file.
    - code:
        code: |
          $ bkl -o out.yaml service.test.toml
        highlights: ["-o out.yaml"]
        languages: [[0, "shell"]]
    - content: |
        The output format is automatically detected from the output filename.

- id: inputs
  title: Inputs
  items:
    - code:
        label: Commandline Layering
        code: |
          $ bkl a.b.yaml c.d.yaml   # a.yaml + a.b.yaml + c.yaml + c.d.yaml
        highlights: ["a.b.yaml c.d.yaml"]
        languages: [[0, "shell"]]
    - content: |
        Specifying multiple input files merges all layers in order.
    - code:
        label: stdin
        code: |
          $ bkl -- -.yaml &lt;&lt;'EOF'
          a: 1
          EOF
        highlights: ["-- -.yaml"]
        languages: [[0, "shell"], [1, "yaml"]]
    - content: |
        Use <highlight>-.yaml</highlight>, <highlight>-.json</highlight>, or <highlight>-.toml</highlight> to read from stdin. Prefix with <highlight>--</highlight> to prevent flag interpretation.

- id: inheritance
  title: Inheritance
  items:
    - content: |
        Inheritance is determined using filenames by default. After stripping the extension, the remaining filename is split on <highlight>.</highlight> and treated as an inheritance hierarchy (e.g. <highlight>a.b.c.yaml</highlight> inherits from <highlight>a.b.&lt;ext&gt;</highlight> inherits from <highlight>a.&lt;ext&gt;</highlight>). Parent layers may have any supported file extension.
    - code:
        label: Set Parent In File
        code: |
          $parent: a.b   # inherits from a.b.<ext>, from a.<ext>
        highlights: ["$parent: a.b"]
        languages: [[0, "yaml"]]
    - content: |
        bkl will check for all supported endings of a manually-specified parent file and will still evaluate layers under the parent in the normal order.
    - side_by_side:
        left:
          label: Parent List
          code: |
            $parent:
            - a
            - b
          highlights: ["$parent:", "- a", "- b"]
          languages: [[0, "yaml"]]
        right:
          label: Parent Wildcard
          code: |
            $parent: a.*
          highlights: ["$parent: a.*"]
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$parent</highlight> supports lists and wildcards for multiple inheritance. Wildcard <highlight>*</highlight> matches one segment only: <highlight>a.*</highlight> matches <highlight>a.b.yaml</highlight> but not <highlight>a.b.c.yaml</highlight>.
    - code:
        label: Set Parent In CLI
        code: |
          $ bkl a.b.yaml c.d.yaml      # a.yaml + a.b.yaml + c.yaml + c.d.yaml
        highlights: ["a.b.yaml c.d.yaml"]
        languages: [[0, "shell"]]
    - content: |
        Layer order can be specified with commandline argument order.
    - code:
        label: No Parent
        code: |
          $parent: false   # no further inheritance
        highlights: ["$parent: false"]
        languages: [[0, "yaml"]]
    - content: |
        Setting <highlight>$parent</highlight> to <highlight>false</highlight> or <highlight>null</highlight> stops any further inheritance regardless of filename structure.

- id: streams
  title: Streams
  items:
    - content: |
        Streams contain multiple documents in one file. YAML uses <highlight>---</highlight> delimiters. JSON formats use newlines (see <a href="https://jsonlines.org/">JSON Lines</a>).
    - content: |
        By default, child documents apply to all parent documents. Use <highlight>$match</highlight> to target specific documents.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
            languages: [[0, "yaml"]]
          - code: |
              c: 3
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            c: 3
            ---
            b: 2
            c: 3
          languages: [[0, "yaml"]]
          highlights: ["c: 3", "c: 3"]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
            languages: [[0, "yaml"]]
          - code: |
              $match:
                b: 2
              c: 3
            highlights: ["$match:", "b: 2"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            ---
            b: 2
            c: 3
          highlights: ["c: 3"]
          languages: [[0, "yaml"]]
    - content: |
        The supplied pattern can match multiple documents and the updates will be applied to all of them. <highlight>$match: {}</highlight> matches any documents with a map as their root element, regardless of parent.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
              ---
              a: 1
            languages: [[0, "yaml"]]
          - code: |
              $match:
                a: 1
              c: 3
            highlights: ["$match:", "a: 1"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            c: 3
            ---
            b: 2
            ---
            a: 1
            c: 3
          highlights: ["c: 3", "c: 3"]
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$invert: true</highlight> inside a <highlight>$match</highlight> block inverts the match, causing it to apply to any documents that do not contain the match criteria.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              ---
              b: 2
            languages: [[0, "yaml"]]
          - code: |
              $match:
                a: 1
                $invert: true
              c: 3
            highlights: ["$match:", "$invert: true"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            ---
            b: 2
            c: 3
          highlights: ["c: 3"]
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$match: null</highlight> forces the updates to apply to a new document.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
            languages: [[0, "yaml"]]
          - code: |
              $match: null
              b: 2
            highlights: ["$match: null"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            ---
            b: 2
          highlights: ["b: 2"]
          languages: [[0, "yaml"]]

- id: maps
  title: Maps
  items:
    - content: |
        Maps are merged by default. Use <highlight>$replace: true</highlight> to replace the entire map or <highlight>$delete</highlight> to remove specific keys.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
            languages: [[0, "yaml"]]
          - code: |
              b: 2
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
            languages: [[0, "yaml"]]
          - code: |
              b: 2
              $replace: true
            highlights: ["$replace: true"]
            languages: [[0, "yaml"]]
        result:
          code: |
            b: 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
            languages: [[0, "yaml"]]
          - code: |
              c: 3
              b: $delete
            highlights: ["b: $delete"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            c: 3
          languages: [[0, "yaml"]]
    - content: |
        bkl returns an error if you use <highlight>$delete</highlight>, <highlight>$replace: true</highlight>, or a <highlight>key: value</highlight> pair when they don't override a value from a lower layer. This helps keep upper layers minimal.

- id: lists
  title: Lists
  items:
    - content: |
        Lists are merged by default. Use <highlight>$replace: true</highlight> to replace the entire list or <highlight>$delete</highlight> to remove specific entries.
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
            languages: [[0, "yaml"]]
          - code: |
              - 2
            languages: [[0, "yaml"]]
        result:
          code: |
            - 1
            - 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
            languages: [[0, "yaml"]]
          - code: |
              - 2
              - $replace: true
            highlights: ["$replace: true"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              - x: 1
              - x: 2
            languages: [[0, "yaml"]]
          - code: |
              - x: 3
              - $delete:
                  x: 2
            highlights: ["$delete:", "x: 2"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - x: 1
            - x: 3
          languages: [[0, "yaml"]]
    - content: |
        bkl returns an error if you use <highlight>$replace: true</highlight> or <highlight>$delete</highlight> when they don't override a value from a lower layer. This helps keep upper layers minimal.
    - content: |
        To update a specific list item, use <highlight>$match</highlight>. For scalar values in lists, use <highlight>$value</highlight> to replace the entire item.
    - example:
        operation: evaluate
        layers:
          - code: |
              - a: 1
              - b: 2
            languages: [[0, "yaml"]]
          - code: |
              - $match:
                  b: 2
                b: 10
            highlights: ["$match:", "b: 2"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - a: 1
            - b: 10
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              - 1
              - 2
            languages: [[0, "yaml"]]
          - code: |
              - $match: 2
                $value: 10
            highlights: ["$match: 2", "$value: 10"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - 1
            - 10
          languages: [[0, "yaml"]]

- id: interp
  title: $""
  items:
    - content: |
        Use <highlight>$""</highlight> to interpolate format strings with <a href="#merge"><highlight>$merge</highlight></a>-style references.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: foo
              d: $"{b.c} bar {a} 2"
            highlights: ["$\"{b.c} bar {a} 2\""]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              c: foo
            d: foo bar 1 2
          languages: [[0, "yaml"]]
          highlights: ["foo bar 1 2"]

- id: decode
  title: $decode
  items:
    - content: |
        <highlight>$decode</highlight> transforms a string into a tree by parsing standard formats.
    - example:
        operation: evaluate
        layers:
          - code: |
              $value: |
                {"a":1}
              $decode: json
            highlights: ["{\"a\":1}", "$decode: json"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
          highlights: ["a: 1"]
          languages: [[0, "yaml"]]

- id: env
  title: $env
  items:
    - content: |
        Use <highlight>$env:</highlight> to substitute environment variables. This is supported in keys and values.
    - example:
        operation: evaluate
        layers:
          - code: |
              # export FOO=test
              "$env:FOO": 1
            highlights: ["\"$env:FOO\""]
            languages: [[0, "yaml"]]
        result:
          code: |
            test: 1
          highlights: ["test"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              # export FOO=test
              a: $env:FOO
            highlights: ["$env:FOO"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: test
          highlights: ["test"]
          languages: [[0, "yaml"]]
    - content: |
        Note that all <highlight>$env:</highlight> substitutions result in string values even if the substituted value is <highlight>true</highlight>, <highlight>false</highlight>, <highlight>null</highlight>, or all digits.

- id: encode
  title: $encode
  items:
    - content: |
        <highlight>$encode</highlight> transforms the subtree into the specified format.
    - example:
        operation: evaluate
        layers:
          - label: base64
            code: |
              $value: a
              $encode: base64
            highlights: ["$encode: base64"]
            languages: [[0, "yaml"]]
        result:
          code: |
            YQ==
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: flags
            code: |
              a: 1
              b: 2
              $encode: flags
              # [tolist:=, prefix:--]
            highlights: ["$encode: flags"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - --a=1
            - --b=2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: flatten
            code: |
              - - a
                - b
              - - c
                - 4
              - e
              - $encode: flatten
            highlights: ["$encode: flatten"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - a
            - b
            - c
            - 4
            - e
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: join
            code: |
              $value: [a, b]
              $encode: join:/
            highlights: ["$encode: join:/"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a/b
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: json
            code: |
              a: 1
              b: 2
              $encode: json
            highlights: ["$encode: json"]
            languages: [[0, "yaml"]]
        result:
          code: |
            |
              {"a":1,"b":2}
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: json (list)
            code: |
              - a: 1
              - b: 2
              - $encode: json
            highlights: ["$encode: json"]
            languages: [[0, "yaml"]]
        result:
          code: |
            |
              [{"a":1},{"b":2}]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: prefix
            code: |
              - a
              - 2
              - $encode: prefix:X
            highlights: ["$encode: prefix:X"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - Xa
            - X2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: sha256
            code: |
              $value: hello world
              $encode: sha256
            highlights: ["$encode: sha256"]
            languages: [[0, "yaml"]]
        result:
          code: |
            b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: tolist
            code: |
              a: 1
              b: 2
              $encode: tolist:=
            highlights: ["$encode: tolist:="]
            languages: [[0, "yaml"]]
        result:
          code: |
            - a=1
            - b=2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: values
            code: |
              a: 1
              b: 2
              c: 3
              $encode: values
            highlights: ["$encode: values"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - 1
            - 2
            - 3
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - label: Stacking
            code: |
              a: 1
              b: 2
              $encode: [tolist:=, "join:,"]
            highlights: ["$encode: [tolist:=, \"join:,\"]"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a=1,b=2
          languages: [[0, "yaml"]]

- id: required
  title: $required
  items:
    - content: |
        Use <highlight>$required</highlight> in lower layers to force upper layers to replace the value.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: $required
            highlights: ["b: $required"]
            languages: [[0, "yaml"]]
          - code: |
              c: 3
            languages: [[0, "yaml"]]
        result:
          code: |
            Error
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: $required
            highlights: ["b: $required"]
            languages: [[0, "yaml"]]
          - code: |
              b: 2
              c: 3
            highlights: ["b: 2"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
            c: 3
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                - $required
            highlights: ["b:", "- $required"]
            languages: [[0, "yaml"]]
          - code: |
              c: 3
            languages: [[0, "yaml"]]
        result:
          code: |
            Error
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                - $required
            highlights: ["b:", "- $required"]
            languages: [[0, "yaml"]]
          - code: |
              b:
                - 2
              c: 3
            highlights: ["b:", "- 2"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              - 2
            c: 3
          languages: [[0, "yaml"]]

- id: merge
  title: $merge
  items:
    - content: |
        Use <highlight>$merge</highlight> to merge the contents one subtree or scalar value into another.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                $merge: foo.bar
            highlights: ["$merge: foo.bar"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              a: 1
              b: 2
          highlights: ["a: 1"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - a: 1
              zig:
                - b: 2
                - $merge: foo.bar
            highlights: ["$merge: foo.bar"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                - a: 1
            zig:
              - b: 2
              - a: 1
          highlights: ["a: 1"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                c: $merge:foo.bar.a
            highlights: ["$merge:foo.bar.a"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              b: 2
              c: 1
          highlights: ["1"]
          languages: [[0, "yaml"]]
    - content: |
        You can also merge across documents using <highlight>$match</highlight> and optionally <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $merge:
                $match:
                  a: 1
            highlights: ["$merge:", "$match:", "a: 1"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
            c: 3
          highlights: ["a: 1", "b: 2"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $merge:
                $match:
                  a: 1
                $path: b
            highlights: ["$merge:", "$match:", "a: 1", "$path: b"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
            d: 4
          highlights: ["c: 3"]
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$merge</highlight> supports a shorthand syntax: <highlight>$merge: [{pattern}, path]</highlight> is equivalent to using <highlight>$match</highlight> and <highlight>$path</highlight>.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $merge: [{a: 1}]
            highlights: ["$merge: [{a: 1}]"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
            c: 3
          highlights: ["a: 1", "b: 2"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $merge: [{a: 1}, b]
            highlights: ["$merge: [{a: 1}, b]"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
            d: 4
          highlights: ["c: 3"]
          languages: [[0, "yaml"]]

- id: replace
  title: $replace
  items:
    - content: |
        Use <highlight>$replace</highlight> to merge the contents of one subtree or scalar value with another.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                $replace: foo.bar
            highlights: ["$replace: foo.bar"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              a: 1
          highlights: ["a: 1"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - a: 1
              zig:
                - b: 2
                - $replace: foo.bar
            highlights: ["$replace: foo.bar"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                - a: 1
            zig:
              - a: 1
          highlights: ["a: 1"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  a: 1
              zig:
                b: 2
                c: $replace:foo.bar.a
            highlights: ["$replace:foo.bar.a"]
            languages: [[0, "yaml"]]
        result:
          code: |
            foo:
              bar:
                a: 1
            zig:
              b: 2
              c: 1
          highlights: ["1"]
          languages: [[0, "yaml"]]
    - content: |
        Note that <highlight>$merge</highlight> and <highlight>$replace</highlight> are equivalent for scalar values.
    - content: |
        You can also replace across documents using <highlight>$match</highlight> and optionally <highlight>$path</highlight>:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $replace:
                $match:
                  a: 1
            highlights: ["$replace:", "$match:", "a: 1"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
          highlights: ["a: 1", "b: 2"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $replace:
                $match:
                  a: 1
                $path: b
            highlights: ["$replace:", "$match:", "a: 1", "$path: b"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$replace</highlight> supports a shorthand syntax: <highlight>$replace: [{pattern}, path]</highlight> is equivalent to using <highlight>$match</highlight> and <highlight>$path</highlight>.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b: 2
              ---
              c: 3
              $replace: [{a: 1}]
            highlights: ["$replace: [{a: 1}]"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
            ---
            a: 1
            b: 2
          highlights: ["a: 1", "b: 2"]
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              b:
                c: 3
              ---
              d: 4
              $replace: [{a: 1}, b]
            highlights: ["$replace: [{a: 1}, b]"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b:
              c: 3
            ---
            c: 3
          highlights: ["c: 3"]
          languages: [[0, "yaml"]]

- id: output
  title: $output
  items:
    - content: |
        Use <highlight>$output: true</highlight> to select a subtree for output instead of the document root.
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  $output: true
                  a: 1
                  b: 2
            highlights: ["$output: true"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              foo:
                bar:
                  - $output: true
                  - a: 1
                  - b: 2
            highlights: ["$output: true"]
            languages: [[0, "yaml"]]
        result:
          code: |
            - a: 1
            - b: 2
          languages: [[0, "yaml"]]
    - content: |
        Multiple instances of <highlight>$output: true</highlight> in a document will generate multiple output documents (delimited with <highlight>---</highlight>).
    - content: |
        Use <highlight>$output: false</highlight> to omit a subtree or entire document from the output.
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                b: 1
                $output: false
              c:
                d: 2
            highlights: ["$output: false"]
            languages: [[0, "yaml"]]
        result:
          code: |
            c:
              d: 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - b: 1
                - $output: false
              c:
                - d: 2
            highlights: ["$output: false"]
            languages: [[0, "yaml"]]
        result:
          code: |
            c:
              - d: 2
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
              $output: false
              ---
              b: 2
            highlights: ["$output: false"]
            languages: [[0, "yaml"]]
        result:
          code: |
            b: 2
          languages: [[0, "yaml"]]
    - content: |
        Combine <highlight>$output</highlight> with <highlight>$merge</highlight> to create reusable template sections.

- id: repeat
  title: $repeat
  items:
    - content: |
        <highlight>$repeat:</highlight> at the top level of a document causes the document to be duplicated the given number of times. Within the document, <highlight>$repeat</highlight> can be used to reference the zero-based repeat index.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: foo
              b: $repeat
              $repeat: 2
            highlights: ["$repeat: 2", "b: $repeat"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: foo
            b: 0
            ---
            a: foo
            b: 1
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$repeat:</highlight> can also contain a map of named repeat iterators to repeat count. The result is the cartesian product (all combinations) of repeat values.
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat:
                a: 2
                b: 3
              $value: $"{$repeat:a},{$repeat:b}"
            highlights: ["$repeat:", "a: 2", "b: 3", "$repeat:a", "$repeat:b"]
            languages: [[0, "yaml"]]
        result:
          code: |
            0,0
            ---
            0,1
            ---
            0,2
            ---
            1,0
            ---
            1,1
            ---
            1,2
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$repeat:</highlight> can contain a list of values to iterate over:
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat: [foo, bar, baz]
              a: $repeat
            highlights: ["$repeat: [foo, bar, baz]", "a: $repeat"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: foo
            ---
            a: bar
            ---
            a: baz
          languages: [[0, "yaml"]]
    - content: |
        <highlight>$repeat:</highlight> supports range parameters for numeric sequences:
    - example:
        operation: evaluate
        layers:
          - code: |
              $repeat:
                $first: 10
                $count: 3
              a: $repeat
            highlights: ["$repeat:", "$first: 10", "$count: 3", "a: $repeat"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 10
            ---
            a: 11
            ---
            a: 12
          languages: [[0, "yaml"]]
    - content: |
        Range parameters require exactly 2 of <highlight>$first</highlight>, <highlight>$last</highlight>, and <highlight>$count</highlight>. Optional <highlight>$step</highlight> defaults to 1.
    - content: |
        <highlight>$repeat:</highlight> also works at the object level within maps and lists:
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                $"b{$repeat}":
                  c: $repeat
                  $repeat: 3
            highlights: ["$repeat: 3", "c: $repeat"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a:
              b0:
                c: 0
              b1:
                c: 1
              b2:
                c: 2
          languages: [[0, "yaml"]]
    - content: |
        Object-level repeat in lists:
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - b: $repeat
                  $repeat: [foo, bar, baz]
            highlights: ["$repeat: [foo, bar, baz]", "b: $repeat"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a:
              - b: foo
              - b: bar
              - b: baz
          languages: [[0, "yaml"]]

- id: escape
  title: $$
  items:
    - content: |
        <highlight>$$</highlight> translates to a literal <highlight>$</highlight> in cases where it would otherwise trigger special handling.
    - example:
        operation: evaluate
        layers:
          - code: |
              a: $$env:foo
            highlights: ["$$env:foo"]
            languages: [[0, "yaml"]]
        result:
          code: |
            a: $env:foo
          highlights: ["$env:foo"]
          languages: [[0, "yaml"]]

- id: toml
  title: TOML
  items:
    - content: |
        TOML doesn't allow unquoted <highlight>$</highlight> in keys. Quote keys containing bkl directives:
    - code:
        code: |
          "$parent" = false
        highlights: ["\"$parent\""]
        languages: [[0, "toml"]]

- id: errors
  title: Errors
  items:
    - content: |
        bkl helps maintain clean layers by reporting errors for unused directives:
    - example:
        operation: evaluate
        layers:
          - code: |
              a: 1
            languages: [[0, "yaml"]]
          - code: |
              b: 2
            languages: [[0, "yaml"]]
        result:
          code: |
            Error: key not found in parent
    - content: |
        This ensures upper layers only contain overrides, not new values. Use the base layer for shared configuration.

- id: bklb
  title: bklb
  items:
    - content: |
        <highlight>bklb</highlight> is a wrapper for CLI programs that take configuration files as commandline arguments but do not support bkl format. It transparently merges layers, translates formats, writes to temporary files, alters the commandline arguments, then execs the wrapped program.
    - code:
        code: |
          $ ln -s ~/go/bin/bklb ~/go/bin/catb   # catb could be, e.g. kubectlb
          
          $ cat service.yaml
          addr: 127.0.0.1
          name: myService
          port: 8080
          
          $ cat service.test.toml
          port = 8081
          
          $ catb service.test.toml
          addr = "127.0.0.1"
          name = "myService"
          port = 8081
          
          $ cat service.test.yaml service.test.json
          cat: service.test.yaml: No such file or directory
          cat: service.test.json: No such file or directory
          
          $ catb service.test.yaml
          addr: 127.0.0.1
          name: myService
          port: 8081
          
          $ catb service.test.json
          {"addr":"127.0.0.1","name":"myService","port":8081}
        languages: [[0, "shell"], [2, "shell"], [3, "yaml"], [7, "shell"], [8, "toml"], [10, "shell"], [11, "toml"], [15, "shell"], [19, "shell"], [20, "yaml"], [24, "shell"], [25, "json"]]
        highlights: ["ln -s ~/go/bin/bklb ~/go/bin/catb", "catb service.test.toml", "catb service.test.yaml", "catb service.test.json"]
    - content: |
        Note that the files mentioned don't have to exist; <highlight>bklb</highlight> will search for files with the same root name but different extensions, then merge layers and translate into the specified format.
    - content: |
        <highlight>bklb</highlight> takes the name of the program it wraps from its own filename, hence the <highlight>ln -s</highlight> symlink creation in the example above. It trims at most one <highlight>b</highlight> from the end of its name before searching for the wrapped program so they can coexist in your PATH.

- id: bkld
  title: bkld
  items:
    - code:
        code: |
          $ bkld &lt;base_layer_path&gt; &lt;target_output_path&gt;
        languages: [[0, "shell"]]
    - content: |
        <highlight>bkld</highlight> (d for "diff") generates the minimal intermediate layer needed to create the target output from the base layer. Along with <highlight><a href="#bkli">bkli</a></highlight>, it automates splitting existing configurations into layers.
    - example:
        operation: diff
        layers:
          - code: |
              a: 1
              b: $required
              c: 3
            languages: [[0, "yaml"]]
          - code: |
              a: 1
              b: 2
              d: 4
            languages: [[0, "yaml"]]
        result:
          code: |
            $match: {}
            b: 2
            c: $delete
            d: 4
          languages: [[0, "yaml"]]
    - example:
        operation: diff
        layers:
          - code: |
              - a: 1
              - b: 2
            languages: [[0, "yaml"]]
          - code: |
              - a: 1
              - c: 3
            languages: [[0, "yaml"]]
        result:
          code: |
            - $match: {}
            - c: 3
            - $delete:
                b: 2
          languages: [[0, "yaml"]]
    - example:
        operation: diff
        layers:
          - code: |
              - 1
              - 2
            languages: [[0, "yaml"]]
          - code: |
              - 1
              - 3
            languages: [[0, "yaml"]]
        result:
          code: |
            - $match: {}
            - 1
            - 3
            - $replace: true
          languages: [[0, "yaml"]]

- id: bkli
  title: bkli
  items:
    - code:
        code: |
          $ bkli &lt;target_output_path&gt; &lt;target_output_path&gt; ...
        languages: [[0, "shell"]]
    - content: |
        <highlight>bkli</highlight> (i for "intersect") generates the maximal base layer that the specified targets have in common. Along with <highlight><a href="#bkld">bkld</a></highlight>, it automates splitting existing configurations into layers.
    - content: |
        Any fields that exist in all upper layers but have different values will be marked <highlight>$required</highlight>.
    - example:
        operation: intersect
        layers:
          - code: |
              a: 1
              b: 2
              c: 3
            languages: [[0, "yaml"]]
          - code: |
              a: 1
              b: 10
              d: 4
            languages: [[0, "yaml"]]
        result:
          code: |
            a: 1
            b: $required
          languages: [[0, "yaml"]]
    - example:
        operation: intersect
        layers:
          - code: |
              - a: 1
              - b: 2
              - c: 3
            languages: [[0, "yaml"]]
          - code: |
              - a: 1
              - b: 10
              - d: 4
            languages: [[0, "yaml"]]
        result:
          code: |
            - a: 1
          languages: [[0, "yaml"]]

- id: bklr
  title: bklr
  items:
    - code:
        code: |
          $ bklr &lt;lower_layer_path&gt;
        languages: [[0, "shell"]]
    - content: |
        <highlight>bklr</highlight> extracts only <highlight>$required</highlight> fields and their parent paths. Use this output as a template for creating minimal upper layers.
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                b: $required
                c: 3
            languages: [[0, "yaml"]]
        result:
          code: |
            a:
              b: $required
          languages: [[0, "yaml"]]
    - example:
        operation: evaluate
        layers:
          - code: |
              a:
                - $required
              b:
                - 2
            languages: [[0, "yaml"]]
        result:
          code: |
            a:
              - $required
          languages: [[0, "yaml"]]

- id: kubectl-bkl
  title: kubectl bkl
  items:
    - code:
        code: |
          $ kubectl bkl &lt;kubectl_commands&gt;
        highlights: ["bkl"]
        languages: [[0, "shell"]]
    - content: |
        <highlight>kubectl bkl</highlight> is a kubectl plugin that wraps all the normal kubectl commands by evaluating any input files as bkl layers and passing the output to kubectl.
    - code:
        code: |
          # deploy.dev.yaml and deploy.yaml are bkl layer files
          $ kubectl bkl apply -f deploy.dev.yaml
          deployment.apps/deploy-dev unchanged
        languages: [[0, "shell"]]

- id: diff
  title: Comparing Files
  items:
    - content: |
        Compare evaluated bkl files using standard diff tools:
    - code:
        code: |
          $ diff -ud --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)
          --- /dev/fd/63  2023-07-12 21:00:55.412475845 -0700
          +++ /dev/fd/62  2023-07-12 21:00:55.412475845 -0700
          @@ -1,3 +1,2 @@
           a: 1
          -b: 2
           c: 3
          
          $ diff -y --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)
          a: 1                              a: 1
          b: 2                            &lt;
          c: 3                              c: 3
        languages: [[0, "shell"], [1, "diff"], [8, "shell"], [9, "diff"]]
        highlights: ["diff -ud --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)", "diff -y --color &lt;(bkl a.yaml) &lt;(bkl b.yaml)"]

- id: migrate
  title: Migrate
  items:
    - content: |
        Below is an example process for migrating an existing set of configurations to <highlight>bkl</highlight>. It contains some Kubernetes-specific items but the use of the <highlight>bkl*</highlight> tools applies to any configuration source.
    - content: |
        We assume you start with two K8s deployments called <highlight>deploy-dev</highlight> and <highlight>deploy-prod</highlight> which are similar but not identical.
    - content: |
        First, install tools:
        
        <ul>
        <li><a href="#install">bkl</a></li>
        <li><a href="https://kubernetes.io/docs/tasks/tools/#kubectl">kubectl</a></li>
        <li><a href="https://krew.sigs.k8s.io/docs/user-guide/setup/install/">krew</a></li>
        <li><a href="https://github.com/itaysk/kubectl-neat#installation">neat</a></li>
        </ul>
    - content: |
        It's possible to export configuration directly from existing templating systems (e.g. <highlight>kustomize build</highlight>, <highlight>helm install --dry-run --debug</highlight>). Instead, we do this in a generic way and make sure we get the latest configuration by fetching it directly from the K8s API server.
    - code:
        label: Export Existing Config
        code: |
          # "kubectl neat" removes status and default value fields
          $ kubectl neat get -- deploy deploy-dev &gt; deploy-dev-orig.yaml
          $ kubectl neat get -- deploy deploy-prod &gt; deploy-prod-orig.yaml
        languages: [[0, "shell"]]
    - code:
        label: Generate Base Layer
        code: |
          # See bkli details <a href="#bkli">here</a>
          $ bkli -o deploy.yaml deploy-dev-orig.yaml deploy-prod-orig.yaml
        languages: [[0, "shell"]]
    - code:
        label: Generate Service Layers
        code: |
          # See bkld details <a href="#bkld">here</a>
          $ bkld -o deploy.dev.yaml deploy.yaml deploy-dev-orig.yaml
          $ bkld -o deploy.prod.yaml deploy.yaml deploy-prod-orig.yaml
        languages: [[0, "shell"]]
    - code:
        label: Check Results
        code: |
          # Should show no diff
          $ kubectl bkl diff -f deploy.dev.yaml
          $ kubectl bkl diff -f deploy.prod.yaml
        languages: [[0, "shell"]]
    - code:
        label: Clean Up
        code: |
          $ rm deploy-dev-orig.yaml deploy-prod-orig.yaml
        languages: [[0, "shell"]]
    - content: |
        You now have 3 bkl files:
        
        <ul>
        <li><highlight>deploy.yaml</highlight> is the base layer containing values common to both deployments</li>
        <li><highlight>deploy.dev.yaml</highlight> is the upper layer containing values specific to <highlight>deploy-dev</highlight></li>
        <li><highlight>deploy.prod.yaml</highlight> is the upper layer containing values specific to <highlight>deploy-prod</highlight></li>
        </ul>
    - content: |
        The migration process isn't deterministic; there are design and aesthetic considerations. Here are some general tips:
        
        <ul>
        <li>Start with the most similar examples to maximize base layer size</li>
        <li>Consider intermediate layers that make sense (e.g. <highlight>deploy.yaml</highlight> → <highlight>deploy.frontend.yaml</highlight> → <highlight>deploy.frontend.prod.yaml</highlight>)</li>
        <li>Split large configurations into logical subfiles; bkl can merge across file boundaries</li>
        <li>Iterate by diffing your evaluated layers against production (e.g. <highlight>kubectl bkl diff -f</highlight>), making small changes, then diffing again.</li>
        <li>Migrate as much as possible to the lowest layer to reduce duplication and complexity.</li>
        <li>Consider making your base layer match your production configuration then overriding values for dev/test configurations. This makes it very clear where you're drifting away from production.</li>
        <li>Remove duplication with <highlight>$merge:</highlight> but avoid chained merge paths.</li>
        <li>Avoid using hidden <highlight>$output: false</highlight> trees as template variables; prefer overriding values in-place.</li>
        <li><highlight>bkld</highlight> doesn't know how to match entries within lists, so it may remove and replace large entries (e.g. K8s <highlight>containers</highlight>) that could be trivially patched. Use <highlight>$match:</highlight> to select the container and override values within it.</li>
        </ul>

- id: comparison
  title: Comparison
  items:
    - content: |
        bkl has some overlap with other configuration templating tools (e.g. <a href="https://helm.sh/">Helm</a>, <a href="https://kustomize.io/">Kustomize</a>, <a href="https://www.puppet.com/docs/puppet/8/hiera_intro.html">Hiera</a>). We believe that bkl has a combination of project goals that aren't fully served by any of the alternatives:
        
        <ul>
        <li>Configuration and templating/layering should be generic, not service-specific.</li>
        <li>Configuration and templating/layering should be separate from deployment tooling.</li>
        <li>Configuration files should be written in standard formats (JSON, YAML, TOML) and parseable by their standard parsers.</li>
        <li>Basic functionality should be available without learning custom syntax.</li>
        <li>Non-templatized configuration (e.g. StackOverflow answers) should be usable without modification.</li>
        <li>File composition should be accomplished without meta configuration (e.g. manifest files).</li>
        <li>Templating/layering behavior should be intuitive and produce expected results.</li>
        <li>Documentation and examples should be excellent.</li>
        </ul>